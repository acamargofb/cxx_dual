
[section Choosing with the dual library]

This area of the documentation explains the mechanisms by which
the CXXD library chooses whether to use the Boost version or the
C++ standard version of a particular module.

[section The default algorithm]

The default algorithm employed by CXXD to choose whether to use a Boost library
or its C++ standard equivalent for any module is very simple. If the C++ standard library is available
during compilation it is chosen and if it is not available during compilation its
equivalent Boost library is chosen.

The determination of availability for any given module is done by examining 
Boost.config macros. Boost config has quite a number of macros which will specify
which C++ standard library is available during compilation. The logic of determining
which library is available is determined within Boost config, and CXXD just uses the
results of that logic to configure a particular module.

The logic of setting the macros for any particular module occurs when the CXXD header for that
module is included in the code. The logic is completely preprocessor macro based, and is specific
to each module's CXXD header, although the logic for each CXXD header is generally the same.

As an example, using the regex module:

    #include <boost/cxxd/regex.hpp>

    ... code
    
If Boost.config determines that the C++ standard regex library is available 
CXXD_HAS_STD_REGEX is defined as '1', CXXD_REGEX_NS is defined as 'std', and 
CXXD_REGEX_HEADER is defined as '<regex>'. If Boost.config determines that the C++ standard regex library 
is not available CXXD_HAS_STD_REGEX is defined as '0', CXXD_REGEX_NS is defined as 'boost', 
and CXXD_REGEX_HEADER is defined as '<boost/regex.hpp>'. 

[endsect]

[section Overriding the default algorithm]

Although CXXD chooses automatically whether the Boost library or the C++ standard library is to be used
for any given module the programmer may decide to override this choice. The method of overriding the choice
is to define a particular macro before including a particular CXXD header.

The programmer may override the automatic choice of CXXD by specifying that the Boost library be used
or by specifying that the C++ standard library be used. If the programmer specifies that the C++ standard
library be used and that library is not available for use, a preprocessor error will be generated.

[heading Specific overriding]

For any given module 'xxx' defining a macro called CXXD_'XXX'_USE_BOOST, where XXX is the uppercase name of 
the module, specifies that the Boost library will be used for module 'xxx'. It does not matter to what 
CXXD_XXX_USE_BOOST is defined.

For any given module 'xxx' defining a macro called CXXD_'XXX'_USE_STD, where XXX is the uppercase name of
the module, specifies that the C++ standard library will be used for module 'xxx'. It does not matter to what 
CXXD_XXX_USE_STD is defined.

If for any given module 'xxx' both CXXD_'XXX'_USE_BOOST and CXXD_'XXX'_USE_STD is defined a preprocessing
error will occur when the CXXD header for module 'xxx' is included.

As examples, using the regex module:

    #define CXXD_REGEX_USE_BOOST
    #include <boost/cxxd/regex.hpp>

    ... code
    
CXXD_HAS_STD_REGEX is defined as '0', CXXD_REGEX_NS is defined as 'boost', 
and CXXD_REGEX_HEADER is defined as '<boost/regex.hpp>'.   

    #define CXXD_REGEX_USE_STD
    #include <boost/cxxd/regex.hpp>

    ... code
    
CXXD_HAS_STD_REGEX is defined as '1', CXXD_REGEX_NS is defined as 'std', 
and CXXD_REGEX_HEADER is defined as '<regex>' as long as the C++ standard
regex library is available for use, else a preprocessing error is generated.

[heading General overriding]

Along with the specific macros of the form CXXD_'XXX'_USE_BOOST and CXXD_'XXX'_USE_STD
which override default processing for module 'xxx' the programmer can specify either
of two generalized macros which overrides default processing for any module.

Defining a macro called CXXD_USE_BOOST specifies that the Boost library will be used 
for any module. It does not matter to what CXXD_USE_BOOST is defined.

Defining a macro called CXXD_USE_STD specifies that the C++ standard library will be used
for any module. It does not matter to what CXXD_USE_STD is defined.

If both CXXD_USE_BOOST and CXXD_USE_STD is defined a preprocessing
error will occur when any CXXD header is included. 

If for any given module 'xxx' both CXXD_'XXX'_USE_BOOST and CXXD_USE_STD is defined
a preprocessing error will occur only if the CXXD header file for module 'xxx' is
included.

If for any given module 'xxx' both CXXD_'XXX'_USE_STD and CXXD_USE_BOOST is defined
a preprocessing error will occur only if the CXXD header file for module 'xxx' is
included.

As examples, using the regex module:

    #define CXXD_USE_BOOST
    #include <boost/cxxd/regex.hpp>

    ... code
    
CXXD_HAS_STD_REGEX is defined as '0', CXXD_REGEX_NS is defined as 'boost', 
and CXXD_REGEX_HEADER is defined as '<boost/regex.hpp>'.   

    #define CXXD_USE_STD
    #include <boost/cxxd/regex.hpp>

    ... code
    
CXXD_HAS_STD_REGEX is defined as '1', CXXD_REGEX_NS is defined as 'std', 
and CXXD_REGEX_HEADER is defined as '<regex>' as long as the C++ standard
regex library is available for use, else a preprocessing error is generated.

    #define CXXD_REGEX_USE_BOOST
    #define CXXD_USE_STD
    #include <boost/cxxd/regex.hpp>

    ... code
    
A preprocessing error is generated.

    #define CXXD_REGEX_USE_STD
    #define CXXD_USE_BOOST
    #include <boost/cxxd/regex.hpp>

    ... code
    
A preprocessing error is generated.

Using any CXXD header:

    #define CXXD_USE_BOOST
    #define CXXD_USE_STD
    #include <boost/cxxd/'any_cxxd_header'

    ... code
    
A preprocessing error is generated.
    
[endsect]

[section Header file inclusion]

CXXD header content is processed each time a particular CXXD header is included 
in a translation unit. This is different from most headers in C++, which use 
inclusion guards or compiler dependent pragmas so that the header file content
only gets processed the first time.

The reason for processing CXXD header content each time a CXXD header is included
is because overriding macros could be defined ( or undefined ) at any time within a translation unit.
CXXD always makes sure that overriding macros do not conflict with each other, as
discussed just previously, and that the choice of either Boost or its equivalent
standard library remains consistent for any particular module within a TU.
    
In actual usage the programmer himself will usually not include the same CXXD header
more than once in a TU. 

    #include <boost/cxxd/regex.hpp>
    ... other #includes
    #include <boost/cxxd/regex.hpp>

    ... code
    
The above will rarely happen.
    
But what far more likely happens is that the programmer includes a non-CXXD
header, often from another library, and that header will include a particular
CXXD header.

    // Header another_library.hpp
    #include <boost/cxxd/regex.hpp>
    ... other #includes

    ... header code
    
A TU with:

    #include <boost/cxxd/regex.hpp>
    #include <another_library.hpp>

    ... code
    
It is this latter case which will often cause a CXXD header to be included
more than once in a TU.

[heading Default algorithm redux]

Recall that the default algorithm is used to choose between the Boost library or its
C++ standard equivalent for a module when no overriding macros are relevant
for that module. Because CXXD header content is processed each time the header is included 
the default algorithm is slightly different the second and subsequent times a particular CXXD header 
is included. In that case the default algorithm simply accepts which of the dual libraries of the module
has been previously chosen. This saves preprocessing time and also makes sure that the choice for a given
module is consistent throughout the TU.

Let's look at how this works in practice with the default algorithm.

    #include <boost/cxxd/regex.hpp>
    
    ... code
    
This is our normal case where the default algorithm will choose the
C++ standard regex library if it is available, otherwise the Boost
regex library.
    
    #include <boost/cxxd/regex.hpp>
    #include <another_library.hpp>

    ... code
    
In this situation when the CXXD regex module is included
a second time, by including another_library.hpp, it simply accepts 
the choice made the first time it was directly included.

    #define CXXD_REGEX_USE_BOOST
    #include <boost/cxxd/regex.hpp>
    #undef CXXD_REGEX_USE_BOOST
    #include <another_library.hpp>

    ... code
    
In this case the first time that the CXXD regex module is included
the default algorithm is not in effect since we have overridden the
choice by specifying that the Boost regex library will be used.
Although in practical experience it would be very unusual to undefine
the overridden macro, we do it here to illustrate the fact that the second
time that the CXXD regex module is included the default algorithm is in effect
but it simply accepts the choice made the first time.

[heading Dual library consistency]

By default whenever a CXXD header for a particular module is included a second 
or subsequent time in a TU the choice of the dual library cannot change from the original
inclusion of that CXXD header. This consistency is enforced because it would normally
cause problems in user's code if, for a given module, one part of the TU were using the C++ standard library 
and another part of the TU were using the Boost library equivalent. This consistency, 
of the same syntax meaning the same thing within a TU,
is something which the CXXD library enforces. CXXD enforces this consistency by creating
a preprocessing error if the dual library choice would change
when a particular CXXD header is included more than once in a TU.

However this consistency means that the order of header file inclusion
potentially changes the way that CXXD works for a given module. To illustrate
this we will use as an example a header file which has a macro override:

    // Header another_library_with_override.hpp
    #define CXXD_REGEX_USE_BOOST
    #include <boost/cxxd/regex.hpp>
    ... other #includes

    ... header code
    
In this header file we override the default processing for the regex
module so that the Boost regex library is always used. Let's also assume
for our example that the C++ standard regex library is available. 
Now if we include the another_library_with_override.hpp header first in 
a TU followed by the CXXD regex header, as in:

    #include <another_library_with_override.hpp>
    ...other header files
    #include <boost/cxxd/regex.hpp>
    
everything works fine. This is because we have the overridden macro
in effect each time to determine that the Boost regex library will
be used.

But if we reverse the order of includes:

    #include <boost/cxxd/regex.hpp>
    ...other header files
    #include <another_library_with_override.hpp>
    
we are essentially changing the dual library choice, in the TU, between the first
time the CXXD regex header is included and the second time it is included.
The first time the CXXD regex header is included no overriding is in effect so that
the default algorithm chooses the C++ standard library because it is available.
The second time the CXXD regex header is included an overriding macro changes the regex
module to use the Boost regex library. Thus consistency between which dual library is chosen
is broken and CXXD creates a preprocessing error.

This is one of the weaknesses of a macro based system such as CXXD. Normally the
order of inclusion of header files should not affect the way that code compiles.
But in CXXD it does affect the compilation since, by default, CXXD does not allow
the dual library for a particular module to change within a TU.

[endsect]

[endsect]
