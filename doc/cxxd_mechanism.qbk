[/ 
  (C) Copyright Edward Diener 2015-2016
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section Choosing the dual library]

This area of the documentation explains the mechanisms by which
the CXXD library chooses whether to use the Boost version or the
C++ standard version of a particular CXXD-mod.

[section The default algorithm]

The default algorithm employed by CXXD to choose whether to use a Boost library
or its C++ standard equivalent for any CXXD-mod is very simple. If the C++ standard library is available
during compilation it is chosen and if it is not available during compilation its
equivalent Boost library is chosen.

The determination of availability for any given module is done by examining 
Boost.Config macros. Boost config has quite a number of macros which will specify
which C++ standard library is available during compilation. The logic of determining
which library is available is determined within Boost.Config, and CXXD just uses the
results of that logic to configure the macros for a particular CXXD-mod.

The logic of setting the macros for any particular CXXD-mod occurs when the CXXD-mod header for that
CXXD-mod is included in the code. The logic is completely preprocessor macro based, and is specific
to each CXXD-mod header, although the logic for each CXXD-mod header is generally the same.

As an example, using the regex CXXD-mod:

    #include <boost/cxx_dual/regex.hpp>
    ... code
    
If Boost.Config determines that the C++ standard regex library is available 
CXXD_HAS_STD_REGEX is defined as '1', CXXD_REGEX_NS is defined as 'std', and 
CXXD_REGEX_HEADER is defined as '<regex>'. If Boost.config determines that the C++ standard regex library 
is not available CXXD_HAS_STD_REGEX is defined as '0', CXXD_REGEX_NS is defined as 'boost', 
and CXXD_REGEX_HEADER is defined as '<boost/regex.hpp>'. 

[endsect]

[section Overriding the default algorithm]

Although CXXD chooses automatically whether the Boost library or the C++ standard library is to be used
for any given CXXD-mod the programmer may decide to override this choice. The method of overriding the choice
is to define a particular macro before including a particular CXXD header.

The programmer may override the automatic choice of CXXD by specifying that the Boost library be used
or by specifying that the C++ standard library be used. If the programmer specifies that the C++ standard
library be used and that library is not available for use, a preprocessor error will be generated.

[heading Specific overriding]

For any given CXXD-mod 'xxx' defining a macro called 'CXXD_XXX_USE_BOOST', where XXX is the uppercase name of 
the CXXD-mod, specifies that the Boost library will be used for 'xxx'. If used CXXD_XXX_USE_BOOST must always 
be defined to nothing, as in:

    #define CXXD_'XXX'_USE_BOOST
    
where XXX is the uppercase name of the module.

For any given CXXD-mod 'xxx' defining a macro called 'CXXD_XXX_USE_STD', where XXX is the uppercase name of
the CXXD-mod, specifies that the C++ standard library will be used for 'xxx'. If used CXXD_XXX_USE_STD must always
be defined to nothing, as in:

    #define CXXD_'XXX'_USE_STD
    
where XXX is the uppercase name of the module.

If for any given CXXD-mod 'xxx' both CXXD_XXX_USE_BOOST and CXXD_XXX_USE_STD is defined a preprocessing
error will occur when the CXXD header for 'xxx' is included.

As examples, using the regex CXXD-mod:

    #define CXXD_REGEX_USE_BOOST
    #include <boost/cxx_dual/regex.hpp>
    ... code
    
CXXD_HAS_STD_REGEX is defined as '0', CXXD_REGEX_NS is defined as 'boost', 
and CXXD_REGEX_HEADER is defined as '<boost/regex.hpp>'.   

    #define CXXD_REGEX_USE_STD
    #include <boost/cxx_dual/regex.hpp>
    ... code
    
CXXD_HAS_STD_REGEX is defined as '1', CXXD_REGEX_NS is defined as 'std', 
and CXXD_REGEX_HEADER is defined as '<regex>' as long as the C++ standard
regex library is available for use, else a preprocessing error is generated.

[heading General overriding]

Along with the specific macros of the form CXXD_XXX_USE_BOOST and CXXD_XXX_USE_STD
which override default processing for the specific 'xxx' CXXD-mod the programmer can specify either
of two generalized macros which overrides default processing for any CXXD-mod.

Defining a macro called CXXD_USE_BOOST specifies that the Boost library will be used 
for any CXXD-mod. If used CXXD_USE_BOOST must always be defined to nothing, as in:

    #define CXXD_USE_BOOST
    
Defining a macro called CXXD_USE_STD specifies that the C++ standard library will be used
for any CXXD-mod. If used CXXD_USE_STD must always be defined to nothing, as in:

    #define CXXD_USE_STD
    
If both CXXD_USE_BOOST and CXXD_USE_STD is defined a preprocessing
error will occur when any CXXD-mod header is included.

If for any given CXXD-mod 'xxx' both CXXD_XXX_USE_BOOST and CXXD_USE_STD is defined
a preprocessing error will occur when the CXXD-mod header file for 'xxx' is
included.

If for any given CXXD-mod 'xxx' both CXXD_XXX_USE_STD and CXXD_USE_BOOST is defined
a preprocessing error will occur when the CXXD=mod header file for 'xxx' is
included.

As examples, using the regex CXXD-mod:

    #define CXXD_USE_BOOST
    #include <boost/cxx_dual/regex.hpp>
    ... code
    
CXXD_HAS_STD_REGEX is defined as '0', CXXD_REGEX_NS is defined as 'boost', 
and CXXD_REGEX_HEADER is defined as '<boost/regex.hpp>'.   

    #define CXXD_USE_STD
    #include <boost/cxx_dual/regex.hpp>
    ... code
    
CXXD_HAS_STD_REGEX is defined as '1', CXXD_REGEX_NS is defined as 'std', 
and CXXD_REGEX_HEADER is defined as '<regex>' as long as the C++ standard
regex library is available for use, else a preprocessing error is generated.

    #define CXXD_REGEX_USE_BOOST
    #define CXXD_USE_STD
    #include <boost/cxx_dual/regex.hpp>
    ... code
    
A preprocessing error is generated.

    #define CXXD_REGEX_USE_STD
    #define CXXD_USE_BOOST
    #include <boost/cxx_dual/regex.hpp>
    ... code
    
A preprocessing error is generated.

Using any CXXD header:

    #define CXXD_USE_BOOST
    #define CXXD_USE_STD
    #include <boost/cxx_dual/'any_cxxd_header'
    ... code
    
A preprocessing error is generated.
    
[heading Purpose of overriding]

The purpose of using overriding macros, for any CXXD-mod with the 
specific overriding macros or for CXXD as a whole with the general
overriding macros, is to override the default algorithm which CXXD
uses to choose a dual library. However using overriding macros 
for one's own direct use(s) of CXXD is foolish. This is because the easiest
implementation, rather than using an overriding macro, is to just
drop CXXD in favor of using either the Boost library or C++ standard
library directly. 

In other words, instead of:

    #define CXXD_USE_BOOST
    #include <boost/cxx_dual/regex.hpp>
    #include CXXD_REGEX_HDR
    CXXD_REGEX_NS::regex my_regex; // etc.
    ... code
    
you can simply code:

    #include <boost/regex.hpp>
    boost::regex my_regex; // etc.
    ... code
    
and instead of:

    #define CXXD_USE_STD
    #include <boost/cxx_dual/regex.hpp>
    #include CXXD_REGEX_HDR
    CXXD_REGEX_NS::regex my_regex; // etc.
    ... code
    
you can simply code:

    #include <regex>
    std::regex my_regex; // etc.
    ... code
    
In this sense the examples given above of using specific or
general overriding macros are purely artificial in order to
merely show what the meaning of these overriding macros entail.
In actual code directly overriding a particular CXXD-mod
should never be done in favor of directly using either the
Boost or C++ standard implementations of a dual library.
    
So what is the actual purpose of the overriding macros ? The purpose
is to override the use of CXXD by another implementation whose source files
should not be modified. A third-party library
may choose to use CXXD to provide a dual library for a particular
CXXD-mod. Your own code, which uses the third-party library but otherwise
uses either the Boost version of the dual library or the C++ standard
version of the dual library in all other situations, may enforce its
own usage on the dual library interface of the third-party library by 
using an overriding macro. As an example a third-party library might have
as a public interface:

    // Header file ThirdPartyHeader.hpp
    #include <boost/cxx_dual/regex.hpp>
    #include CXXD_REGEX_HEADER
    class ThirdPartyClass
        {
        public:
        void SomeFunction(CXXD_REGEX_NS::regex &);
        ... // other functionality
        };
        
We will assume this is a header-only library for the time being
( a discussion of using CXXD with a non-header-only library will
follow later in the documentation ). In one's own code you may desire
to use the ThirdPartyClass::SomeFunction interface with specifically
the Boost regex library only. Your own code might then look like:

    #define CXXD_REGEX_USE_BOOST
    #include <ThirdPartyHeader.hpp>
    boost::regex my_regex("SomeRegularExpression etc.");
    ThirdPartyClass tpclass;
    tpclass.SomeFunction(my_regex);
    
Conversely you may decide that your use of the ThirdPartyClass::SomeFunction interface 
should be with the C++ standard regex library only, so your code might then look like:

    #define CXXD_REGEX_USE_STD
    #include <ThirdPartyHeader.hpp>
    std::regex my_regex("SomeRegularExpression etc.");
    ThirdPartyClass tpclass;
    tpclass.SomeFunction(my_regex);
    
Instead if you did accept the dual nature of the ThirdPartyHeader.hpp header, your code
might then like:
    
    #include <ThirdPartyHeader.hpp>
    CXXD_REGEX_NS::regex my_regex("SomeRegularExpression etc.");
    ThirdPartyClass tpclass;
    tpclass.SomeFunction(my_regex);
    
In other words using the overriding macros of CXXD serves the purpose
of using some already established interface involving CXXD without
changing that interface's own code, at the same time forcing the choice
of a particular dual library to be used.
    
[endsect]

[section Header file inclusion]

CXXD-mod header content is processed each time a particular CXXD-mod header is included 
in a translation unit. This is different from most headers in C++, which use 
inclusion guards or compiler dependent pragmas so that the header file content
only gets processed the first time.

The reason for processing CXXD-mod header content each time a CXXD-mod header is included
is because overriding macros could be defined ( or undefined ) at any time within a translation unit.
CXXD always makes sure that overriding macros do not conflict with each other, as
discussed previously, and that the choice of either Boost or its equivalent
standard library remains consistent for any particular module within a TU.
    
In actual usage the programmer himself will usually not include the same CXXD header
more than once in a TU. 

    #include <boost/cxx_dual/regex.hpp>
    ... other #includes
    #include <boost/cxx_dual/regex.hpp>
    ... code
    
The above is possible but will rarely happen.
    
What far more likely happens is that the programmer includes a non-CXXD
header, often from another library, and that header will include a particular
CXXD-mod header.

    // Header another_library.hpp
    #include <boost/cxx_dual/regex.hpp>
    ... other #includes
    ... header code
    
A TU with:

    #include <boost/cxx_dual/regex.hpp>
    #include <another_library.hpp>
    ... code
    
It is this latter case which will often cause a CXXD-mod header to be included
more than once in a TU.

[heading Default algorithm redux]

Recall that the default algorithm is used to choose between the Boost library or its
C++ standard equivalent for a CXXD-mod when no overriding macros are relevant
for that CXXD-mod. Because CXXD-mod header content is processed each time the header is included 
the default algorithm is slightly different the second and subsequent times a particular CXXD-mod header 
is included. In that case the default algorithm simply accepts which of the dual libraries of the module
has been previously chosen. This saves preprocessing time and also makes sure that the choice for a given
module is consistent throughout the TU.

Let's look at how this works in practice with the default algorithm.

    #include <boost/cxx_dual/regex.hpp>
    ... code
    
This is our normal case where the default algorithm will choose the
C++ standard regex library if it is available, otherwise the Boost
regex library.
    
    // Header another_library.hpp
    #include <boost/cxx_dual/regex.hpp>
    ... other #includes
    ... header code

    // Header my_header.hpp
    #include <boost/cxx_dual/regex.hpp>
    #include <another_library.hpp>
    ... code
    
In this situation when the regex CXXD-mod is included
a second time in my_header.hpp, by including another_library.hpp, it simply accepts 
the choice made the first time it was directly included.

    // Header another_library.hpp
    #include <boost/cxx_dual/regex.hpp>
    ... other #includes
    ... header code
    
    // Header my_header.hpp
    #define CXXD_REGEX_USE_BOOST
    #include <boost/cxx_dual/regex.hpp>
    #undef CXXD_REGEX_USE_BOOST
    #include <another_library.hpp>
    ... code
    
In this case the first time that the regex CXXD-mod is included in
my_header.hpp the default algorithm is not in effect since we have overridden the
choice by specifying that the Boost regex library will be used.
Although in practical experience it would be very unusual to undefine
the overridden macro, we do it here to illustrate the fact that the second
time that the regex CXXD-mod is included in my_header.hpp the default algorithm is in effect
but it simply accepts the choice made the first time, which is to use the
Boost regex library. This is done even if the C++ standard regex library is available.

[heading Dual library consistency]

By default whenever a CXXD-mod header for a particular CXXD-mod is included a second 
or subsequent time in a TU the choice of the dual library cannot change from the original
inclusion of that CXXD-mod header. This consistency is enforced because it would normally
cause problems in user's code if, for a given CXXD-mod, one part of the TU were using the C++ standard library 
and another part of the TU were using the Boost library equivalent. This consistency, 
of the same syntax meaning the same thing within a TU,
is something which the CXXD library enforces. CXXD enforces this consistency by creating
a preprocessing error if the dual library choice would change
when a particular CXXD header is included more than once in a TU.

However this consistency means that the order of header file inclusion
potentially changes the way that CXXD works for a given end-user's module. This is the major
downside of CXXD so we will take a look at it. To illustrate
this we will use as an example a header file which has an overriding macro:

    // Header another_library_with_override.hpp
    #define CXXD_REGEX_USE_BOOST
    #include <boost/cxx_dual/regex.hpp>
    ... other #includes
    ... header code
    
In this header file we override the default processing for the regex
CXXD-mod so that the Boost regex library is always used. Let's also assume
for our example that the C++ standard regex library is available. 
Now if we include the another_library_with_override.hpp header first in 
a TU followed by the CXXD regex header, as in:

    #include <another_library_with_override.hpp>
    ...other header files
    #include <boost/cxx_dual/regex.hpp>
    
everything works fine. This is because we have the overridden macro
in effect each time to determine that the Boost regex library will
be used.

But if we reverse the order of includes:

    #include <boost/cxx_dual/regex.hpp>
    ...other header files
    #include <another_library_with_override.hpp>
    
we are essentially changing the dual library choice, in the TU, between the first
time the regex CXXD-mod header is included and the second time it is included.
The first time the regex CXXD-mod header is included no overriding macro is in effect so that
the default algorithm chooses the C++ standard library because it is available.
The second time the regex CXXD-mod header is included an overriding macro changes the regex
module to use the Boost regex library. Thus consistency between which dual library is chosen
is broken and CXXD creates a preprocessing error.

This is one of the weaknesses of a macro based system such as CXXD. Normally the
order of inclusion of header files should not affect the way that code compiles.
But in CXXD it does affect the compilation since, by default, CXXD does not allow
the dual library choice for a particular module to change within a TU.

[#mechanism_noconsistency] The end user can override the dual library consistency for all CXXD-mods by defining
a macro, called CXXD_NO_CONSISTENCY. If used CXXD_NO_CONSISTENCY must always be defined to nothing, as in:

    #define CXXD_NO_CONSISTENCY

Overriding dual library consistency for a TU is a serious matter and should
not be done lightly. CXXD does not recommend doing this but in the spirit of flexibility
allows it. Overriding consistency allows the dual library for a CXXD-mod to change when that
CXXD-mod's CXXD header file is included more than once. In actuality, unless the end-user
goes about undefining already defined overriding macros, the only case where overriding
the dual library consistency by defining CXXD_NO_CONSISTENCY will normally cause the
dual library for a module to change within a TU
is in the second example given above, ie. when the default algorithm chooses a dual
library the first time a CXXD=mod header is included and then an overriding macro changes the dual library
with the opposite choice the second time the CXXD-mod header is included. In all other
cases merely adding further override macros before further inclusions will either
cause overriding macro conflicts, which will always produce preprocessing errors from
within CXXD, or not change the dual library chosen in any further way. 

It is highly recommended that CXXD_NO_CONSISTENCY not be used unless the programmer knows
exactly what the code is doing in a particular TU including all intermediate header
file code. When dual library consistency is turned off using CXXD_NO_CONSISTENCY 
the chance that CXXD macros for a particular module will access the Boost
library in some part of a TU and the C++ standard library in another part of a TU,
and the problems this may cause, are generally not worth the problems that could occur in code
confusion. Nonetheless if the programmer feels he knows what he is doing in using this
macro he can do so.

An alternative to using the dangerous CXXD_NO_CONSISTENCY macro is to define
an overriding macro at the very beginning of a TU, either in the TU itself or
by some compiler command line parameter which allows a macro definition to be made. This maintains
TU consistency but should really only be done if using CXXD produces a preprocessor
error based on consistency for a TU being broken.

[endsect]

[endsect]
