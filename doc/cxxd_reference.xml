<?xml version="1.0" standalone="yes"?>
<library-reference id="reference"><title>Reference</title><header name="boost/cxx_dual/array.hpp">
<para>Dual library for the array implementation. </para><para>Chooses either the Boost array implementation or the C++ standard array implementation. </para><macro name="CXXD_HAS_STD_ARRAY"><purpose>Determines whether the C++ standard array implementation or the Boost array implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard array implementation has been chosen 0 if the Boost array implementation has been chosen. </para></description></macro>
<macro name="CXXD_ARRAY_NS"><purpose>The array namespace. </purpose><description><para>The object-like macro expands to the namespace for the array implementation. </para></description></macro>
<macro name="CXXD_ARRAY_HEADER"><purpose>The array header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the array header file. The macro is used with the syntax: #include CXXD_ARRAY_HEADER </para></description></macro>
<macro name="CXXD_ARRAY_USE_STD"><purpose>Override macro for C++ standard array implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard array implementation. If the C++ standard array implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_ARRAY_USE_BOOST"><purpose>Override macro for Boost array implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost array implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/atomic.hpp">
<para>Dual library for atomic data type. </para><para>Chooses either the Boost atomic implementation or the C++ standard atomic implementation. </para><macro name="CXXD_HAS_STD_ATOMIC"><purpose>Determines whether the C++ standard atomic implementation or the Boost atomic implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard atomic implementation has been chosen 0 if the Boost atomic implementation has been chosen. </para></description></macro>
<macro name="CXXD_ATOMIC_NS"><purpose>The atomic namespace. </purpose><description><para>The object-like macro expands to the namespace for the atomic implementation. </para></description></macro>
<macro name="CXXD_ATOMIC_HEADER"><purpose>The atomic header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the atomic header file. The macro is used with the syntax: #include CXXD_ATOMIC_HEADER </para></description></macro>
<macro name="CXXD_ATOMIC_MACRO" kind="functionlike"><macro-parameter name="macro"/><purpose>Generates an object-like macro name from the 'macro' name passed to it. </purpose><description><para>The function-like macro expands to the name of an atmomic object-like macro name for any given atomic macro name passed to it. </para></description></macro>
<macro name="CXXD_ATOMIC_USE_STD"><purpose>Override macro for C++ standard atomic implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard atomic implementation. If the C++ standard atomic implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_ATOMIC_USE_BOOST"><purpose>Override macro for Boost atomic implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost atomic implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/bind.hpp">
<para>Dual library for the bind implementation. </para><para>Chooses either the Boost bind implementation or the C++ standard bind implementation. </para><macro name="CXXD_HAS_STD_BIND"><purpose>Determines whether the C++ standard bind implementation or the Boost bind implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard bind implementation has been chosen 0 if the Boost bind implementation has been chosen. </para></description></macro>
<macro name="CXXD_BIND_NS"><purpose>The bind namespace. </purpose><description><para>The object-like macro expands to the namespace for the bind implementation. </para></description></macro>
<macro name="CXXD_BIND_HEADER"><purpose>The bind header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the bind header file. The macro is used with the syntax: #include CXXD_BIND_HEADER </para></description></macro>
<macro name="CXXD_BIND_USE_STD"><purpose>Override macro for C++ standard bind implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard bind implementation. If the C++ standard bind implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_BIND_USE_BOOST"><purpose>Override macro for Boost bind implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost bind implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/chrono.hpp">
<para>Dual library for chrono implementation. </para><para>Chooses either the Boost chrono implementation or the C++ standard chrono implementation. </para><macro name="CXXD_HAS_STD_CHRONO"><purpose>Determines whether the C++ standard chrono implementation or the Boost chrono implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard chrono implementation has been chosen 0 if the Boost chrono implementation has been chosen. </para></description></macro>
<macro name="CXXD_CHRONO_NS"><purpose>The chrono namespace. </purpose><description><para>The object-like macro expands to the namespace for the chrono implementation. </para></description></macro>
<macro name="CXXD_CHRONO_HEADER"><purpose>The chrono header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the chrono header file. The macro is used with the syntax: #include CXXD_CHRONO_HEADER </para></description></macro>
<macro name="CXXD_CHRONO_USE_STD"><purpose>Override macro for C++ standard chrono implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard chrono implementation. If the C++ standard chrono implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_CHRONO_USE_BOOST"><purpose>Override macro for Boost chrono implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost chrono implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/condition_variable.hpp">
<para>Dual library for the condition_variable implementation. </para><para>Chooses either the Boost condition_variable implementation or the C++ standard condition_variable implementation. </para><macro name="CXXD_HAS_STD_CONDITION_VARIABLE"><purpose>Determines whether the C++ standard condition_variable implementation or the Boost condition_variable implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard condition_variable implementation has been chosen 0 if the Boost condition_variable library has been chosen. </para></description></macro>
<macro name="CXXD_CONDITION_VARIABLE_NS"><purpose>The condition_variable namespace. </purpose><description><para>The object-like macro expands to the namespace for the condition_variable implementation. </para></description></macro>
<macro name="CXXD_CONDITION_VARIABLE_HEADER"><purpose>The condition_variable header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the condition_variable header file. The macro is used with the syntax: #include CXXD_CONDITION_VARIABLE_HEADER </para></description></macro>
<macro name="CXXD_CONDITION_VARIABLE_USE_STD"><purpose>Override macro for C++ standard condition_variable implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard condition_variable implementation. If the C++ standard condition_variable implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_CONDITION_VARIABLE_USE_BOOST"><purpose>Override macro for Boost condition_variable implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost condition_variable implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/cxx_mods.hpp">
<para>Includes all dual libraries in a single header. </para><para>Header file to include all the dual libraries with a single include. </para><macro name="CXXD_NO_CONFIG"><purpose>Macro which allows an override for the C++ standard implementation of a CXXD-mod to be successful even when it is unavailable. </purpose><description><para>The object-like macro, when defined to nothing prior to including any CXXD-mod header file, allows the dual choice of the C++ standard implementation through a macro override to be successful even when the C++ standard implementation for that CXXD-mod is unavailable. CXXD determines availability of the C++ standard implementation of a particular CXXD-mod through settings in Boost.Config. When an override macro is used to force the dual library choice of the C++ standard implementation for a particular CXXD-mod, and CXXD determines through Boost.Config that the C++ standard implementation is not available, a preprocessing error normally occurs. Using this macro tells CXXD ro set the dual library choice to the C++ standard implementation without producing a preprocessor error. </para></description></macro>
<macro name="CXXD_NO_CONSISTENCY"><purpose>Macro which turns off CXXD consistency for any CXXD-mod header file. </purpose><description><para>The object-like macro, when defined to nothing prior to including any CXXD-mod header file, turns off CXXD consistency checking and error reporting for that CXXD-mod header file. CXXD consistency makes sure that a dual library choice for a particular CXXD-mod does not change no matter how many times that CXXD-mod is included in a TU ( translation unit ). When CXXD consistency is enforced changing the dual library choice in a TU causes a preprocessing error. Using this macro allows the dual library choice for a particular CXXD-mod to change at different points of a TU. </para></description></macro>
<macro name="CXXD_USE_STD"><purpose>Override macro for any C++ standard implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including any CXXD-mod header file, forces the dual library choice of the C++ standard implementation for that CXXD-mod. If the C++ standard implementation for that CXXD-mod is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_USE_BOOST"><purpose>Override macro for any Boost implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including any CXXD-mod header file, forces the dual library choice of the Boost implementation for that CXXD-mod. </para></description></macro>
</header>
<header name="boost/cxx_dual/enable_shared_from_this.hpp">
<para>Dual library for the enable_shared_from_this implementation. </para><para>Chooses either the Boost enable_shared_from_this_implementation or the C++ standard enable_shared_from_this implementation. </para><macro name="CXXD_HAS_STD_ENABLE_SHARED_FROM_THIS"><purpose>Determines whether the C++ standard enable_shared_from_this implementation or the Boost enable_shared_from_this implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard enable_shared_from_this implementation has been chosen 0 if the Boost enable_shared_from_this implementation has been chosen. </para></description></macro>
<macro name="CXXD_ENABLE_SHARED_FROM_THIS_NS"><purpose>The enable_shared_from_this namespace. </purpose><description><para>The object-like macro expands to the namespace for the enable_shared_from_this implementation. </para></description></macro>
<macro name="CXXD_ENABLE_SHARED_FROM_THIS_HEADER"><purpose>The enable_shared_from_this header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the enable_shared_from_this header file. The macro is used with the syntax: #include CXXD_ENABLE_SHARED_FROM_THIS_HEADER </para></description></macro>
<macro name="CXXD_ENABLE_SHARED_FROM_THIS_USE_STD"><purpose>Override macro for C++ standard enable_shared_from_this implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard enable_shared_from_this implementation. If the C++ standard enable_shared_from_this implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_ENABLE_SHARED_FROM_THIS_USE_BOOST"><purpose>Override macro for Boost enable_shared_from_this implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost enable_shared_from_this implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/function.hpp">
<para>Dual library for the function implementation. </para><para>Chooses either the Boost function implementation or the C++ standard function implementation. </para><macro name="CXXD_HAS_STD_FUNCTION"><purpose>Determines whether the C++ standard function implementation or the Boost function implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard function implementation has been chosen 0 if the Boost function implementation has been chosen. </para></description></macro>
<macro name="CXXD_FUNCTION_NS"><purpose>The function namespace. </purpose><description><para>The object-like macro expands to the namespace for the function implementation. </para></description></macro>
<macro name="CXXD_FUNCTION_HEADER"><purpose>The function header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the function header file. The macro is used with the syntax: #include CXXD_FUNCTION_HEADER </para></description></macro>
<macro name="CXXD_FUNCTION_USE_STD"><purpose>Override macro for C++ standard function implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard function implementation. If the C++ standard function implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_FUNCTION_USE_BOOST"><purpose>Override macro for Boost function implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost function implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/hash.hpp">
<para>Dual library for the hash implementation. </para><para>Chooses either the Boost hash implementation or the C++ standard hash implementation. </para><macro name="CXXD_HAS_STD_HASH"><purpose>Determines whether the C++ standard hash implementation or the Boost hash implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard hash implementation has been chosen 0 if the Boost hash implementation has been chosen. </para></description></macro>
<macro name="CXXD_HASH_NS"><purpose>The hash namespace. </purpose><description><para>The object-like macro expands to the namespace for the hash implementation. </para></description></macro>
<macro name="CXXD_HASH_HEADER"><purpose>The hash header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the hash header file. The macro is used with the syntax: #include CXXD_HASH_HEADER </para></description></macro>
<macro name="CXXD_HASH_USE_STD"><purpose>Override macro for C++ standard hash implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard hash implementation. If the C++ standard hash implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_HASH_USE_BOOST"><purpose>Override macro for Boost hash implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost hash implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/library_name.hpp">
<para>Contains CXXD_LIBRARY_NAME macro. </para><macro name="CXXD_LIBRARY_NAME" kind="functionlike"><macro-parameter name="..."/><purpose>Automatically names a non-header only library. </purpose><description><para>The function-like macro expands to the name of a non-header only library. It is useful for non-header only libraries in which different library variants are generated depending on the dual library choices for the CXXD-mods being used in the built portion of the library. The macro by default will expand to a unique library name depending on the dual library choices. The macro works based on the CXXD-mods included before the macro is invoked.</para><para>The required first variadic parameter is the base library name. The generated library name will be the base library name and possibly other mnemonics appended to it. The base library name should be the library name as it would be called if no CXXD-mods were being used in the built portion of the library.</para><para>Each optional variadic parameter is a Boost PP tuple with one to three elements. The Boost PP tuple designates:</para><para><itemizedlist>
<listitem><para>A CXXD-mod identifier. The CXXD-mod identifier is 'CXXD_' followed by the name of a CXXD-mod in uppercase. The CXXD-mod identifiers are specified in a separate list below.</para></listitem><listitem><para>A mnemonic to be appended to the base library name if the CXXD-mod is using its C++ standard implementation.</para></listitem><listitem><para>A mnemonic to be appended to the base library name if the CXXD-mod is using its Boost implementation.</para></listitem></itemizedlist>
</para><para>The first tuple element is required. The second tuple element may be empty or left out. The third tuple element may be empty or left out.</para><para>A tuple element that is left out is considered 'empty'. An empty element is valid and means that nothing will be appended to the base name if the case is met.</para><para>When a tuple is specified as an optional parameter it is important that the mnemonic to be appended be different whether the CXXD-mod is using its C++ standard implementation or its Boost implementation, else there is no guarantee that a unique library name will be generated depending on the CXXD-mods being included. However lack of a difference in the mnemonics, if it occurs, is not flagged as an error in the processing of the macro.</para><para>If an optional parameter is not specified for a particular CXXD-mod which is included, a default value is appended as a mnemonic for the particular CXXD-mod if the CXXD-mod is using its C++ standard implementation; otherwise by default if the CXXD-mod is using its Boost implementation no value is appended by default.</para><para>The CXXD-mod identifiers and their default values for the C++ standard implementation are:</para><para><itemizedlist>
<listitem><para>CXXD_ARRAY,_ar</para></listitem><listitem><para>CXXD_ATOMIC,_at</para></listitem><listitem><para>CXXD_BIND,_bd</para></listitem><listitem><para>CXXD_CHRONO,_ch</para></listitem><listitem><para>CXXD_CONDITION_VARIABLE,_cv</para></listitem><listitem><para>CXXD_ENABLE_SHARED_FROM_THIS,_es</para></listitem><listitem><para>CXXD_FUNCTION,_fn</para></listitem><listitem><para>CXXD_HASH,_ha</para></listitem><listitem><para>CXXD_MAKE_SHARED,_ms</para></listitem><listitem><para>CXXD_MEM_FN,_mf</para></listitem><listitem><para>CXXD_MOVE,_mv</para></listitem><listitem><para>CXXD_MUTEX,_mx</para></listitem><listitem><para>CXXD_RANDOM,_rd</para></listitem><listitem><para>CXXD_RATIO,_ra</para></listitem><listitem><para>CXXD_REF,_rf</para></listitem><listitem><para>CXXD_REGEX,_rx</para></listitem><listitem><para>CXXD_SHARED_MUTEX,_sm</para></listitem><listitem><para>CXXD_SHARED_PTR,_sp</para></listitem><listitem><para>CXXD_SYSTEM_ERROR,_se</para></listitem><listitem><para>CXXD_THREAD,_th</para></listitem><listitem><para>CXXD_TUPLE,_tu</para></listitem><listitem><para>CXXD_TYPE_INDEX,_ti</para></listitem><listitem><para>CXXD_TYPE_TRAITS,_tt</para></listitem><listitem><para>CXXD_UNORDERED_MAP,_um</para></listitem><listitem><para>CXXD_UNORDERED_MULTIMAP,_up</para></listitem><listitem><para>CXXD_UNORDERED_MULTISET,_ut</para></listitem><listitem><para>CXXD_UNORDERED_SET,_us</para></listitem><listitem><para>CXXD_WEAK_PTR,_wp</para></listitem><listitem><para>CXXD_MODS_ALL,_std</para></listitem></itemizedlist>
</para><para>The CXXD_MODS_ALL name refers to what happens if all the included CXXD-mods use either the C++ standard implementation or the Boost implementation. In this case, instead of each individual CXXD-mod having its mnemonic appended to the base name, a single mnemonic is appended to the base name. In the default case for CXXD_MODS_ALL the mnemonic '_std' is appended to the base name if all the included CXXD-mods use the C++ standard implementation and nothing is appended to the base name if all the included CXXD-mods use the Boost implementation.</para><para>The use of the optional parameters is the way to override the default processing for any particular CXXD-mod, or for all CXXD-mods. </para></description></macro>
</header>
<header name="boost/cxx_dual/make_shared.hpp">
<para>Dual library for the make_shared implementation. </para><para>Chooses either the Boost make_shared implementation or the C++ standard make_shared implementation. </para><macro name="CXXD_HAS_STD_MAKE_SHARED"><purpose>Determines whether the C++ standard make_shared implementation or the Boost make_shared implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard make_shared implementation has been chosen 0 if the Boost make_shared implementation has been chosen. </para></description></macro>
<macro name="CXXD_MAKE_SHARED_NS"><purpose>The make_shared namespace. </purpose><description><para>The object-like macro expands to the namespace for the make_shared implementation. </para></description></macro>
<macro name="CXXD_MAKE_SHARED_HEADER"><purpose>The make_shared header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the make_shared header file. The macro is used with the syntax: #include CXXD_MAKE_SHARED_HEADER </para></description></macro>
<macro name="CXXD_MAKE_SHARED_USE_STD"><purpose>Override macro for C++ standard make_shared implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard make_shared implementation. If the C++ standard make_shared implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_MAKE_SHARED_USE_BOOST"><purpose>Override macro for Boost make_shared implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost make_shared implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/mem_fn.hpp">
<para>Dual library for the mem_fn implementation. </para><para>Chooses either the Boost mem_fn implementation or the C++ standard mem_fn implementation. </para><macro name="CXXD_HAS_STD_MEM_FN"><purpose>Determines whether the C++ standard mem_fn implementation or the Boost mem_fn implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard mem_fn implementation has been chosen 0 if the Boost mem_fn implementation has been chosen. </para></description></macro>
<macro name="CXXD_MEM_FN_NS"><purpose>The mem_fn namespace. </purpose><description><para>The object-like macro expands to the namespace for the mem_fn implementation. </para></description></macro>
<macro name="CXXD_MEM_FN_HEADER"><purpose>The mem_fn header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the mem_fn header file. The macro is used with the syntax: #include CXXD_MEM_FN_HEADER </para></description></macro>
<macro name="CXXD_MEM_FN_USE_STD"><purpose>Override macro for C++ standard mem_fn implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard mem_fn implementation. If the C++ standard mem_fn implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_MEM_FN_USE_BOOST"><purpose>Override macro for Boost mem_fn implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost mem_fn implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/move.hpp">
<para>Dual library for the move implementation. </para><para>Chooses either the Boost move implementation or the C++ standard move implementation. </para><macro name="CXXD_HAS_STD_MOVE"><purpose>Determines whether the C++ standard move implementation or the Boost move implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard move implementation has been chosen 0 if the Boost move implementation has been chosen. </para></description></macro>
<macro name="CXXD_MOVE_NS"><purpose>The move namespace. </purpose><description><para>The object-like macro expands to the namespace for the move implementation. </para></description></macro>
<macro name="CXXD_MOVE_HEADER"><purpose>The move header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the move header file. The macro is used with the syntax: #include CXXD_MOVE_HEADER </para></description></macro>
<macro name="CXXD_MOVE_USE_STD"><purpose>Override macro for C++ standard move implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard move implementation. If the C++ standard move implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_MOVE_USE_BOOST"><purpose>Override macro for Boost move implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost move implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/mutex.hpp">
<para>Dual library for the mutex implementation. </para><para>Chooses either the Boost mutex implementation or the C++ standard mutex implementation. </para><macro name="CXXD_HAS_STD_MUTEX"><purpose>Determines whether the C++ standard mutex implementation or the Boost mutex implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard mutex implementation has been chosen 0 if the Boost mutex implementation has been chosen. </para></description></macro>
<macro name="CXXD_MUTEX_NS"><purpose>The mutex namespace. </purpose><description><para>The object-like macro expands to the namespace for the mutex implementation. </para></description></macro>
<macro name="CXXD_MUTEX_HEADER"><purpose>The mutex header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the mutex header file. The macro is used with the syntax: #include CXXD_MUTEX_HEADER </para></description></macro>
<macro name="CXXD_MUTEX_USE_STD"><purpose>Override macro for C++ standard mutex implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard mutex implementation. If the C++ standard mutex implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_MUTEX_USE_BOOST"><purpose>Override macro for Boost mutex implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost mutex implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/random.hpp">
<para>Dual library for the random implementation. </para><para>Chooses either the Boost random implementation or the C++ standard random implementation. </para><macro name="CXXD_HAS_STD_RANDOM"><purpose>Determines whether the C++ standard random implementation or the Boost random implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard random implementation has been chosen 0 if the Boost random implementation has been chosen. </para></description></macro>
<macro name="CXXD_RANDOM_NS"><purpose>The random namespace. </purpose><description><para>The object-like macro expands to the namespace for the random implementation. </para></description></macro>
<macro name="CXXD_RANDOM_HEADER"><purpose>The random header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the random header file. The macro is used with the syntax: #include CXXD_RANDOM_HEADER </para></description></macro>
<macro name="CXXD_RANDOM_USE_STD"><purpose>Override macro for C++ standard random implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard random implementation. If the C++ standard random implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_RANDOM_USE_BOOST"><purpose>Override macro for Boost random implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost random implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/ratio.hpp">
<para>Dual library for the ratio implementation. </para><para>Chooses either the Boost ratio implementation or the C++ standard ratio implementation. </para><macro name="CXXD_HAS_STD_RATIO"><purpose>Determines whether the C++ standard ratio implementation or the Boost ratio implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard ratio implementation has been chosen 0 if the Boost ratio implementation has been chosen. </para></description></macro>
<macro name="CXXD_RATIO_NS"><purpose>The ratio namespace. </purpose><description><para>The object-like macro expands to the namespace for the ratio implementation. </para></description></macro>
<macro name="CXXD_RATIO_HEADER"><purpose>The ratio header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the ratio header file. The macro is used with the syntax: #include CXXD_RATIO_HEADER </para></description></macro>
<macro name="CXXD_RATIO_USE_STD"><purpose>Override macro for C++ standard ratio implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard ratio implementation. If the C++ standard ratio implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_RATIO_USE_BOOST"><purpose>Override macro for Boost ratio implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost ratio implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/ref.hpp">
<para>Dual library for the ref implementation. </para><para>Chooses either the Boost ref implementation or the C++ standard ref implementation. </para><macro name="CXXD_HAS_STD_REF"><purpose>Determines whether the C++ standard ref implementation or the Boost ref implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard ref implementation has been chosen 0 if the Boost ref implementation has been chosen. </para></description></macro>
<macro name="CXXD_REF_NS"><purpose>The ref namespace. </purpose><description><para>The object-like macro expands to the namespace for the ref implementation. </para></description></macro>
<macro name="CXXD_REF_HEADER"><purpose>The ref header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the ref header file. The macro is used with the syntax: #include CXXD_REF_HEADER </para></description></macro>
<macro name="CXXD_REF_USE_STD"><purpose>Override macro for C++ standard ref implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard ref implementation. If the C++ standard ref implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_REF_USE_BOOST"><purpose>Override macro for Boost ref implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost ref implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/regex.hpp">
<para>Dual library for the regex implementation. </para><para>Chooses either the Boost regex implementation or the C++ standard regex implementation. </para><macro name="CXXD_HAS_STD_REGEX"><purpose>Determines whether the C++ standard regex implementation or the Boost regex implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard regex implementation has been chosen 0 if the Boost regex implementation has been chosen. </para></description></macro>
<macro name="CXXD_REGEX_NS"><purpose>The regex namespace. </purpose><description><para>The object-like macro expands to the namespace for the regex implementation. </para></description></macro>
<macro name="CXXD_REGEX_HEADER"><purpose>The regex header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the regex header file. The macro is used with the syntax: #include CXXD_REGEX_HEADER </para></description></macro>
<macro name="CXXD_REGEX_USE_STD"><purpose>Override macro for C++ standard regex implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard regex implementation. If the C++ standard regex implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_REGEX_USE_BOOST"><purpose>Override macro for Boost regex implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost regex implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/shared_mutex.hpp">
<para>Dual library for the shared_mutex implementation. </para><para>Chooses either the Boost shared_mutex implementation or the C++ standard shared_mutex implementation. </para><macro name="CXXD_HAS_STD_SHARED_MUTEX"><purpose>Determines whether the C++ standard shared_mutex implementation or the Boost shared_mutex implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard shared_mutex implementation has been chosen 0 if the Boost shared_mutex implementation has been chosen. </para></description></macro>
<macro name="CXXD_SHARED_MUTEX_NS"><purpose>The shared_mutex namespace. </purpose><description><para>The object-like macro expands to the namespace for the shared_mutex implementation. </para></description></macro>
<macro name="CXXD_SHARED_MUTEX_HEADER"><purpose>The shared_mutex header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the shared_mutex header file. The macro is used with the syntax: #include CXXD_SHARED_MUTEX_HEADER </para></description></macro>
<macro name="CXXD_SHARED_MUTEX_USE_STD"><purpose>Override macro for C++ standard shared_mutex implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard shared_mutex implementation. If the C++ standard shared_mutex implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_SHARED_MUTEX_USE_BOOST"><purpose>Override macro for Boost shared_mutex implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost shared_mutex implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/shared_ptr.hpp">
<para>Dual library for the shared_ptr implementation. </para><para>Chooses either the Boost shared_ptr implementation or the C++ standard shared_ptr implementation. </para><macro name="CXXD_HAS_STD_SHARED_PTR"><purpose>Determines whether the C++ standard shared_ptr implementation or the Boost shared_ptr implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard shared_ptr implementation has been chosen 0 if the Boost shared_ptr implementation has been chosen. </para></description></macro>
<macro name="CXXD_SHARED_PTR_NS"><purpose>The shared_ptr namespace. </purpose><description><para>The object-like macro expands to the namespace for the shared_ptr implementation. </para></description></macro>
<macro name="CXXD_SHARED_PTR_HEADER"><purpose>The shared_ptr header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the shared_ptr header file. The macro is used with the syntax: #include CXXD_SHARED_PTR_HEADER</para><para>The included header file includes the shared_ptr implementation as well as the weak_ptr, make_shared, and enable_shared_from_this implementations. </para></description></macro>
<macro name="CXXD_SHARED_PTR_ONLY_HEADER"><purpose>The shared_ptr header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the shared_ptr header file. The macro is used with the syntax: #include CXXD_SHARED_PTR_HEADER</para><para>The included header file includes only the shared_ptr implementation. </para></description></macro>
<macro name="CXXD_SHARED_PTR_USE_STD"><purpose>Override macro for C++ standard shared_ptr implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard shared_ptr implementation. If the C++ standard shared_ptr implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_SHARED_PTR_USE_BOOST"><purpose>Override macro for Boost shared_ptr implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost shared_ptr implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/system_error.hpp">
<para>Dual library for the system error implementation. </para><para>Chooses either the Boost system error implementation or the C++ standard system error implementation. </para><macro name="CXXD_HAS_STD_SYSTEM_ERROR"><purpose>Determines whether the C++ standard system error implementation or the Boost system error implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard system error implementation has been chosen 0 if the Boost system error implementation has been chosen. </para></description></macro>
<macro name="CXXD_SYSTEM_ERROR_NS"><purpose>The system error namespace. </purpose><description><para>The object-like macro expands to the namespace for the system error implementation. </para></description></macro>
<macro name="CXXD_SYSTEM_ERROR_HEADER"><purpose>The system error header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the system error header file. The macro is used with the syntax: #include CXXD_SYSTEM_ERROR_HEADER </para></description></macro>
<macro name="CXXD_SYSTEM_ERROR_USE_STD"><purpose>Override macro for C++ standard system error implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard system error implementation. If the C++ standard system error implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_SYSTEM_ERROR_USE_BOOST"><purpose>Override macro for Boost system error implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost system error implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/thread.hpp">
<para>Dual library for the thread implementation. </para><para>Chooses either the Boost thread implementation or the C++ standard thread implementation. </para><macro name="CXXD_HAS_STD_THREAD"><purpose>Determines whether the C++ standard thread implementation or the Boost thread implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard thread implementation has been chosen 0 if the Boost thread implementation has been chosen. </para></description></macro>
<macro name="CXXD_THREAD_NS"><purpose>The thread namespace. </purpose><description><para>The object-like macro expands to the namespace for the thread implementation. </para></description></macro>
<macro name="CXXD_THREAD_HEADER"><purpose>The thread header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the thread header file. The macro is used with the syntax: #include CXXD_THREAD_HEADER </para></description></macro>
<macro name="CXXD_THREAD_USE_STD"><purpose>Override macro for C++ standard thread implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard thread implementation. If the C++ standard thread implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_THREAD_USE_BOOST"><purpose>Override macro for Boost thread implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost thread implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/tuple.hpp">
<para>Dual library for the tuple implementation. </para><para>Chooses either the Boost tuple implementation or the C++ standard tuple implementation. </para><macro name="CXXD_HAS_STD_TUPLE"><purpose>Determines whether the C++ standard tuple implementation or the Boost tuple implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard tuple implementation has been chosen 0 if the Boost tuple implementation has been chosen. </para></description></macro>
<macro name="CXXD_TUPLE_NS"><purpose>The tuple namespace. </purpose><description><para>The object-like macro expands to the namespace for the tuple implementation. </para></description></macro>
<macro name="CXXD_TUPLE_HEADER"><purpose>The tuple header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the tuple header file. The macro is used with the syntax: #include CXXD_TUPLE_HEADER </para></description></macro>
<macro name="CXXD_TUPLE_USE_STD"><purpose>Override macro for C++ standard tuple implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard tuple implementation. If the C++ standard tuple implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_TUPLE_USE_BOOST"><purpose>Override macro for Boost tuple implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost tuple implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/type_index.hpp">
<para>Dual library for the type_index implementation. </para><para>Chooses either the Boost type_index implementation or the C++ standard type_index implementation. </para><macro name="CXXD_HAS_STD_TYPE_INDEX"><purpose>Determines whether the C++ standard type_index implementation or the Boost type_index implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard type_index implementation has been chosen 0 if the Boost type_index implementation has been chosen. </para></description></macro>
<macro name="CXXD_TYPE_INDEX_NS"><purpose>The type_index namespace. </purpose><description><para>The object-like macro expands to the namespace for the type_index implementation. </para></description></macro>
<macro name="CXXD_TYPE_INDEX_HEADER"><purpose>The type_index header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the type_index header file. The macro is used with the syntax: #include CXXD_TYPE_INDEX_HEADER </para></description></macro>
<macro name="CXXD_TYPE_INDEX_USE_STD"><purpose>Override macro for C++ standard type_index implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard type_index implementation. If the C++ standard type_index implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_TYPE_INDEX_USE_BOOST"><purpose>Override macro for Boost type_index implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost type_index implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/type_traits.hpp">
<para>Dual library for the type_traits implementation. </para><para>Chooses either the Boost type_traits implementation or the C++ standard type_traits implementation. </para><macro name="CXXD_HAS_STD_TYPE_TRAITS"><purpose>Determines whether the C++ standard type_traits implementation or the Boost type_traits implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard type_traits implementation has been chosen 0 if the Boost type_traits implementation has been chosen. </para></description></macro>
<macro name="CXXD_TYPE_TRAITS_NS"><purpose>The type_traits namespace. </purpose><description><para>The object-like macro expands to the namespace for the type_traits implementation. </para></description></macro>
<macro name="CXXD_TYPE_TRAITS_HEADER"><purpose>The type_traits header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the type_traits header file. The macro is used with the syntax: #include CXXD_TYPE_TRAITS_HEADER </para></description></macro>
<macro name="CXXD_TYPE_TRAITS_USE_STD"><purpose>Override macro for C++ standard type_traits implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard type_traits implementation. If the C++ standard type_traits implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_TYPE_TRAITS_USE_BOOST"><purpose>Override macro for Boost type_traits implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost type_traits implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/unordered_map.hpp">
<para>Dual library for the unordered_map implementation. </para><para>Chooses either the Boost unordered_map implementation or the C++ standard unordered_map implementation. </para><macro name="CXXD_HAS_STD_UNORDERED_MAP"><purpose>Determines whether the C++ standard unordered_map implementation or the Boost unordered_map implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard unordered_map implementation has been chosen 0 if the Boost unordered_map implementation has been chosen. </para></description></macro>
<macro name="CXXD_UNORDERED_MAP_NS"><purpose>The unordered_map namespace. </purpose><description><para>The object-like macro expands to the namespace for the unordered_map implementation. </para></description></macro>
<macro name="CXXD_UNORDERED_MAP_HEADER"><purpose>The unordered_map header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the unordered_map header file. The macro is used with the syntax: #include CXXD_UNORDERED_MAP_HEADER </para></description></macro>
<macro name="CXXD_UNORDERED_MAP_USE_STD"><purpose>Override macro for C++ standard unordered_map implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard unordered_map implementation. If the C++ standard unordered_map implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_UNORDERED_MAP_USE_BOOST"><purpose>Override macro for Boost unordered_map implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost unordered_map implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/unordered_multimap.hpp">
<para>Dual library for the unordered_multimap implementation. </para><para>Chooses either the Boost unordered_multimap implementation or the C++ standard unordered_multimap implementation. </para><macro name="CXXD_HAS_STD_UNORDERED_MULTIMAP"><purpose>Determines whether the C++ standard unordered_multimap implementation or the Boost unordered_multimap implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard unordered_multimap implementation has been chosen 0 if the Boost unordered_multimap implementation has been chosen. </para></description></macro>
<macro name="CXXD_UNORDERED_MULTIMAP_NS"><purpose>The unordered_multimap namespace. </purpose><description><para>The object-like macro expands to the namespace for the unordered_multimap implementation. </para></description></macro>
<macro name="CXXD_UNORDERED_MULTIMAP_HEADER"><purpose>The unordered_multimap header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the unordered_multimap header file. The macro is used with the syntax: #include CXXD_UNORDERED_MULTIMAP_HEADER </para></description></macro>
<macro name="CXXD_UNORDERED_MULTIMAP_USE_STD"><purpose>Override macro for C++ standard unordered_multimap implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard unordered_multimap implementation. If the C++ standard unordered_multimap implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_UNORDERED_MULTIMAP_USE_BOOST"><purpose>Override macro for Boost unordered_multimap implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost unordered_multimap implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/unordered_multiset.hpp">
<para>Dual library for the unordered_multiset implementation. </para><para>Chooses either the Boost unordered_multiset implementation or the C++ standard unordered_multiset implementation. </para><macro name="CXXD_HAS_STD_UNORDERED_MULTISET"><purpose>Determines whether the C++ standard unordered_multiset implementation or the Boost unordered_multiset implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard unordered_multiset implementation has been chosen 0 if the Boost unordered_multiset implementation has been chosen. </para></description></macro>
<macro name="CXXD_UNORDERED_MULTISET_NS"><purpose>The unordered_multiset namespace. </purpose><description><para>The object-like macro expands to the namespace for the unordered_multiset implementation. </para></description></macro>
<macro name="CXXD_UNORDERED_MULTISET_HEADER"><purpose>The unordered_multiset header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the unordered_multiset header file. The macro is used with the syntax: #include CXXD_UNORDERED_MULTISET_HEADER </para></description></macro>
<macro name="CXXD_UNORDERED_MULTISET_USE_STD"><purpose>Override macro for C++ standard unordered_multiset implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard unordered_multiset implementation. If the C++ standard unordered_multiset implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_UNORDERED_MULTISET_USE_BOOST"><purpose>Override macro for Boost unordered_multiset implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost unordered_multiset implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/unordered_set.hpp">
<para>Dual library for the unordered_set implementation. </para><para>Chooses either the Boost unordered_set implementation or the C++ standard unordered_set implementation. </para><macro name="CXXD_HAS_STD_UNORDERED_SET"><purpose>Determines whether the C++ standard unordered_set implementation or the Boost unordered_set implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard unordered_set implementation has been chosen 0 if the Boost unordered_set implementation has been chosen. </para></description></macro>
<macro name="CXXD_UNORDERED_SET_NS"><purpose>The unordered_set namespace. </purpose><description><para>The object-like macro expands to the namespace for the unordered_set implementation. </para></description></macro>
<macro name="CXXD_UNORDERED_SET_HEADER"><purpose>The unordered_set header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the unordered_set header file. The macro is used with the syntax: #include CXXD_UNORDERED_SET_HEADER </para></description></macro>
<macro name="CXXD_UNORDERED_SET_USE_STD"><purpose>Override macro for C++ standard unordered_set implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard unordered_set implementation. If the C++ standard unordered_set implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_UNORDERED_SET_USE_BOOST"><purpose>Override macro for Boost unordered_set implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost unordered_set implementation. </para></description></macro>
</header>
<header name="boost/cxx_dual/valid_variants.hpp">
<para>Contains CXXD_VALID_VARIANTS macro. </para><macro name="CXXD_VALID_VARIANTS" kind="functionlike"><macro-parameter name="..."/><purpose>Tests for valid dual library variants. </purpose><description><para>The function-like macro tests for valid dual library variants. A variant consists of a series of CXXD-mod choices encoded as a variadic parameter. A CXXD-mod choice refers to whether the CXXD-mod chooses the C++ standard implementation or the Boost implementation.</para><para>If the CXXD-mod choices, based on the CXXD headers being included before the macro, is invoked match any one of the variants, the macro expands to 1, otherwise the macro expands to 0.</para><para>The macro provides a single invocation where the creator of a library or executable can test whether or not combinations of CXXD-mod choices match what the programmer wants to allow. In cases of header-only libraries or executables it should never be necessary to limit the combinations in any way, but in the case of a non-header only library the library implementor may well want to limit the acceptable combinations because supporting all possible variants, each with their own name and need to be built, might well prove onerous.</para><para>A variant is encoded by a series, known as a VMD sequence, of two-element Boost PP tuples. The first element is a particular CXXD-mod identifier, given in a following list, and the second element is 1 if the desired choice is the C++ standard implementation of that CXXD-mod or 0 if the desired choice is the Boost implementation of that CXXD-mod.</para><para>The VMD sequence of each choice makes up a combination of dual library choices, which denote a valid variant which the macro invoker says that his library will allow.</para><para>The list of CXXD-mod identifiers and their CXXD-mod is:</para><para><itemizedlist>
<listitem><para>CXXD_ARRAY,array</para></listitem><listitem><para>CXXD_ATOMIC,atomic</para></listitem><listitem><para>CXXD_BIND,bind</para></listitem><listitem><para>CXXD_CHRONO,chrono</para></listitem><listitem><para>CXXD_CONDITION_VARIABLE,condition_variable</para></listitem><listitem><para>CXXD_ENABLE_SHARED_FROM_THIS,enable_shared_from_this</para></listitem><listitem><para>CXXD_FUNCTION,function</para></listitem><listitem><para>CXXD_HASH,hash</para></listitem><listitem><para>CXXD_MAKE_SHARED,make_shared</para></listitem><listitem><para>CXXD_MEM_FN,mem_fn</para></listitem><listitem><para>CXXD_MOVE,move</para></listitem><listitem><para>CXXD_MUTEX,mutex</para></listitem><listitem><para>CXXD_RANDOM,random</para></listitem><listitem><para>CXXD_RATIO,ratio</para></listitem><listitem><para>CXXD_REF,ref</para></listitem><listitem><para>CXXD_REGEX,regex</para></listitem><listitem><para>CXXD_SHARED_MUTEX,shared_mutex</para></listitem><listitem><para>CXXD_SHARED_PTR,shared_ptr</para></listitem><listitem><para>CXXD_SYSTEM_ERROR,system_error</para></listitem><listitem><para>CXXD_THREAD,thread</para></listitem><listitem><para>CXXD_TUPLE,tuple</para></listitem><listitem><para>CXXD_TYPE_INDEX,type_index</para></listitem><listitem><para>CXXD_TYPE_TRAITS,type_traits</para></listitem><listitem><para>CXXD_UNORDERED_MAP,unordered_map</para></listitem><listitem><para>CXXD_UNORDERED_MULTIMAP,unordered_multimap</para></listitem><listitem><para>CXXD_UNORDERED_MULTISET,unordered_multiset</para></listitem><listitem><para>CXXD_UNORDERED_SET,unorderd_set</para></listitem><listitem><para>CXXD_WEAK_PTR,weak_ptr</para></listitem><listitem><para>CXXD_MODS_ALL,all mods</para></listitem></itemizedlist>
</para><para>As can be seen each CXXD-mod identifier is 'CXXD_' followed by the uppercase name of the CXXD-mod.</para><para>The CXXD_MODS_ALL identifier refers to all of the included CXXD headers choosing either the C++ standard implementation or the Boost implementation. Therefore if this identifier is used its Boost PP tuple should be the only one in the VMD sequence for that variant.</para><para>The macro invoker must pass at least one variant as a variadic parameter otherwise there is no point in using this macro, but may specify any number of further variants as variadic parameters.</para><para>A protoypical variant will look like: (CXXD_XXX,1 or 0)(CXXD_YYY,1 or 0)(CXXD_ZZZ,1 or 0)...
</para><para>where CCXD_XXX, CXXD_YYY, and CXXD_ZZZ are one of the CXXD-mod identifiers listed above and the '1 or 0' denotes either the C++ standard implementation or Boost implementation as a choice for that CXXD-mod. There can be one or more Boost PP tuples in the VMD sequence which denote the variant. A variant is an 'AND' proposition where each Boost PP tuple in the VMD sequence must be true for the variant to match. Each variant as a variadic parameter is an 'OR' proposition where any variant must match for the macro to return 1. Otherwise the macro returns 0 if none of the variants match. </para></description></macro>
</header>
<header name="boost/cxx_dual/weak_ptr.hpp">
<para>Dual library for the weak_ptr implementation. </para><para>Chooses either the Boost weak_ptr implementation or the C++ standard weak_ptr implementation. </para><macro name="CXXD_HAS_STD_WEAK_PTR"><purpose>Determines whether the C++ standard weak_ptr implementation or the Boost weak_ptr implementation has been chosen. </purpose><description><para>The object-like macro expands to: 1 if the C++ standard weak_ptr implementation has been chosen 0 if the Boost weak_ptr implementation has been chosen. </para></description></macro>
<macro name="CXXD_WEAK_PTR_NS"><purpose>The weak_ptr namespace. </purpose><description><para>The object-like macro expands to the namespace for the weak_ptr implementation. </para></description></macro>
<macro name="CXXD_WEAK_PTR_HEADER"><purpose>The weak_ptr header file name. </purpose><description><para>The object-like macro expands to the include header file designation for the weak_ptr header file. The macro is used with the syntax: #include CXXD_WEAK_PTR_HEADER </para></description></macro>
<macro name="CXXD_WEAK_PTR_USE_STD"><purpose>Override macro for C++ standard weak_ptr implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the C++ standard weak_ptr implementation. If the C++ standard weak_ptr implementation is not available a preprocessor error is generated. </para></description></macro>
<macro name="CXXD_WEAK_PTR_USE_BOOST"><purpose>Override macro for Boost weak_ptr implementation. </purpose><description><para>The object-like macro, when defined to nothing prior to including this header file, forces the dual library choice of the Boost weak_ptr implementation. </para></description></macro>
</header>
</library-reference>
